// Autogenerated from Pigeon (v0.2.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/services.dart';

class PhotoPickerOptions {
  /// 选择照片类型，0 = 图片，1 = 视频，2 = 混合
  int? type;

  /// 可选资源最大数
  int? maxAssetsCount;

  /// 是否可以编辑资源
  bool? allowEdit;

  /// 编辑 - 单选模式下选择图片时是否直接跳转到编辑界面
  bool? singleJumpEdit;

  /// 编辑 - 是否使用圆形剪裁
  bool? isRoundCliping;

  /// 编辑 - 是否支持旋转
  bool? supportRotation;

  /// 编辑 - 自定义剪裁比例，宽度
  int? photoEditCustomRatioW;

  /// 编辑 - 自定义剪裁比例，高度
  int? photoEditCustomRatioH;

  /// 列表每行显示个数
  int? imageSpanCount;

  /// 是否允许在相册打开相机
  bool? allowOpenCamera;

  /// 是否加载Gif
  bool? allowGif;

  int? videoMaximumDuration;
  int? videoMinimumDuration;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['type'] = type;
    pigeonMap['maxAssetsCount'] = maxAssetsCount;
    pigeonMap['allowEdit'] = allowEdit;
    pigeonMap['singleJumpEdit'] = singleJumpEdit;
    pigeonMap['isRoundCliping'] = isRoundCliping;
    pigeonMap['supportRotation'] = supportRotation;
    pigeonMap['photoEditCustomRatioW'] = photoEditCustomRatioW;
    pigeonMap['photoEditCustomRatioH'] = photoEditCustomRatioH;
    pigeonMap['imageSpanCount'] = imageSpanCount;
    pigeonMap['allowOpenCamera'] = allowOpenCamera;
    pigeonMap['allowGif'] = allowGif;
    pigeonMap['videoMaximumDuration'] = videoMaximumDuration;
    pigeonMap['videoMinimumDuration'] = videoMinimumDuration;
    return pigeonMap;
  }

  static PhotoPickerOptions decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoPickerOptions()
      ..type = pigeonMap['type'] as int?
      ..maxAssetsCount = pigeonMap['maxAssetsCount'] as int?
      ..allowEdit = pigeonMap['allowEdit'] as bool?
      ..singleJumpEdit = pigeonMap['singleJumpEdit'] as bool?
      ..isRoundCliping = pigeonMap['isRoundCliping'] as bool?
      ..supportRotation = pigeonMap['supportRotation'] as bool?
      ..photoEditCustomRatioW = pigeonMap['photoEditCustomRatioW'] as int?
      ..photoEditCustomRatioH = pigeonMap['photoEditCustomRatioH'] as int?
      ..imageSpanCount = pigeonMap['imageSpanCount'] as int?
      ..allowOpenCamera = pigeonMap['allowOpenCamera'] as bool?
      ..allowGif = pigeonMap['allowGif'] as bool?
      ..videoMinimumDuration = pigeonMap['videoMinimumDuration'] as int?
      ..videoMaximumDuration = pigeonMap['videoMaximumDuration'] as int?;
  }
}

class PhotoPicker {
  /// Constructor for [PhotoPicker].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PhotoPicker({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  Future<PhotoPickerResult> pickPhoto(PhotoPickerOptions arg) async {
    final Object encoded = arg.encode();
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PhotoPicker.pickPhoto',
        const StandardMessageCodec(),
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(encoded) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return PhotoPickerResult.decode(replyMap['result']!);
    }
  }
}

class PhotoPickerResult {
  List<Object?>? assets;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['assets'] = assets?.map((e) => (e as PhotoAsset).encode());
    return pigeonMap;
  }

  static PhotoPickerResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoPickerResult()
      ..assets = (pigeonMap['assets'] as List<Object?>?)
          ?.map((e) => PhotoAsset.decode(e!))
          .toList();
  }
}

class PhotoAsset {
  String? filePath;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['filePath'] = filePath;
    return pigeonMap;
  }

  static PhotoAsset decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoAsset()..filePath = pigeonMap['filePath'] as String?;
  }

  @override
  String toString() => 'PhotoAsset(filePath: $filePath)';
}
