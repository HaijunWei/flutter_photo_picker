// Autogenerated from Pigeon (v0.2.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/services.dart';

enum PhotoPickerType {
  all,
  image,
  video,
}

class PhotoPickerOptions {
  /// 选择照片类型，0 = 图片，1 = 视频，2 = 混合
  PhotoPickerType type = PhotoPickerType.all;

  /// 可选资源最大数
  int maxAssetsCount = 9;

  /// 是否可以编辑资源
  bool allowEdit = true;

  /// 编辑 - 单选模式下选择图片时是否直接跳转到编辑界面
  bool singleJumpEdit = true;

  /// 编辑 - 是否使用圆形剪裁
  bool isRoundCliping = false;

  /// 编辑 - 自定义剪裁比例，宽度
  int photoEditCustomRatioW = 0;

  /// 编辑 - 自定义剪裁比例，高度
  int photoEditCustomRatioH = 0;

  /// 列表每行显示个数
  int imageSpanCount = 4;

  /// 是否允许在相册打开相机
  bool allowOpenCamera = true;

  /// 是否允许选择Gif
  bool allowGif = false;

  int? videoMaximumDuration;
  int? videoMinimumDuration;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    int type;
    switch (this.type) {
      case PhotoPickerType.image:
        type = 0;
        break;
      case PhotoPickerType.video:
        type = 1;
        break;
      default:
        type = 2;
        break;
    }
    pigeonMap['type'] = type;
    pigeonMap['maxAssetsCount'] = maxAssetsCount;
    pigeonMap['allowEdit'] = allowEdit;
    pigeonMap['singleJumpEdit'] = singleJumpEdit;
    pigeonMap['isRoundCliping'] = isRoundCliping;
    pigeonMap['photoEditCustomRatioW'] = photoEditCustomRatioW;
    pigeonMap['photoEditCustomRatioH'] = photoEditCustomRatioH;
    pigeonMap['imageSpanCount'] = imageSpanCount;
    pigeonMap['allowOpenCamera'] = allowOpenCamera;
    pigeonMap['allowGif'] = allowGif;
    pigeonMap['videoMaximumDuration'] = videoMaximumDuration;
    pigeonMap['videoMinimumDuration'] = videoMinimumDuration;
    return pigeonMap;
  }

  static PhotoPickerOptions decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    int type = pigeonMap['type'] as int;
    PhotoPickerType _type;
    if (type == 0) {
      _type = PhotoPickerType.image;
    } else if (type == 1) {
      _type = PhotoPickerType.video;
    } else {
      _type = PhotoPickerType.all;
    }
    return PhotoPickerOptions()
      ..type = _type
      ..maxAssetsCount = pigeonMap['maxAssetsCount'] as int
      ..allowEdit = pigeonMap['allowEdit'] as bool
      ..singleJumpEdit = pigeonMap['singleJumpEdit'] as bool
      ..isRoundCliping = pigeonMap['isRoundCliping'] as bool
      ..photoEditCustomRatioW = pigeonMap['photoEditCustomRatioW'] as int
      ..photoEditCustomRatioH = pigeonMap['photoEditCustomRatioH'] as int
      ..imageSpanCount = pigeonMap['imageSpanCount'] as int
      ..allowOpenCamera = pigeonMap['allowOpenCamera'] as bool
      ..allowGif = pigeonMap['allowGif'] as bool
      ..videoMinimumDuration = pigeonMap['videoMinimumDuration'] as int?
      ..videoMaximumDuration = pigeonMap['videoMaximumDuration'] as int?;
  }
}

class PhotoPicker {
  /// Constructor for [PhotoPicker].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PhotoPicker({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  Future<PhotoPickerResult> pickPhoto(PhotoPickerOptions arg) async {
    final Object encoded = arg.encode();
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PhotoPicker.pickPhoto',
        const StandardMessageCodec(),
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(encoded) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return PhotoPickerResult.decode(replyMap['result']!);
    }
  }

  Future<PhotoPickerResult> pickPhotoFromCamera(PhotoPickerOptions arg) async {
    final Object encoded = arg.encode();
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PhotoPicker.pickPhotoFromCamera',
        const StandardMessageCodec(),
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(encoded) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return PhotoPickerResult.decode(replyMap['result']!);
    }
  }
}

class PhotoPickerResult {
  List<Object?>? assets;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['assets'] = assets?.map((e) => (e as PhotoAsset).encode());
    return pigeonMap;
  }

  static PhotoPickerResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoPickerResult()
      ..assets = (pigeonMap['assets'] as List<Object?>?)
          ?.map((e) => PhotoAsset.decode(e!))
          .toList();
  }
}

class PhotoAsset {
  String? filePath;
  double width = 0;
  double height = 0;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['filePath'] = filePath;
    pigeonMap['width'] = width;
    pigeonMap['height'] = height;
    return pigeonMap;
  }

  static PhotoAsset decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoAsset()
      ..filePath = pigeonMap['filePath'] as String?
      ..width = pigeonMap['width'] as double? ?? 0
      ..height = pigeonMap['height'] as double? ?? 0;
  }

  @override
  String toString() =>
      'PhotoAsset(filePath: $filePath, width: $width, height: $height)';
}
