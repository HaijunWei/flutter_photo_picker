// Autogenerated from Pigeon (v0.2.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/services.dart';

class PhotoPickerResult {
  List<Object?>? assets;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['assets'] = assets?.map((e) => (e as PhotoAsset).encode());
    return pigeonMap;
  }

  static PhotoPickerResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoPickerResult()
      ..assets = (pigeonMap['assets'] as List<Object?>?)
          ?.map((e) => PhotoAsset.decode(e!))
          .toList();
  }
}

class PhotoAsset {
  String? filePath;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['filePath'] = filePath;
    return pigeonMap;
  }

  static PhotoAsset decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    print(pigeonMap);
    return PhotoAsset()..filePath = pigeonMap['filePath'] as String?;
  }

  @override
  String toString() => 'PhotoAsset(filePath: $filePath)';
}

class PhotoPickerOptions {
  int? type;
  int? maxAssetsCount;
  bool? allowEdit;
  int? videoMaximumDuration;
  int? videoMinimumDuration;
  bool? singleJumpEdit;
  bool? isRoundCliping;
  bool? reverseDate;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['type'] = type;
    pigeonMap['maxAssetsCount'] = maxAssetsCount;
    pigeonMap['allowEdit'] = allowEdit;
    pigeonMap['videoMaximumDuration'] = videoMaximumDuration;
    pigeonMap['videoMinimumDuration'] = videoMinimumDuration;
    pigeonMap['singleJumpEdit'] = singleJumpEdit;
    pigeonMap['isRoundCliping'] = isRoundCliping;
    pigeonMap['reverseDate'] = reverseDate;
    return pigeonMap;
  }

  static PhotoPickerOptions decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PhotoPickerOptions()
      ..type = pigeonMap['type'] as int?
      ..maxAssetsCount = pigeonMap['maxAssetsCount'] as int?
      ..allowEdit = pigeonMap['allowEdit'] as bool?
      ..videoMaximumDuration = pigeonMap['videoMaximumDuration'] as int?
      ..videoMinimumDuration = pigeonMap['videoMinimumDuration'] as int?
      ..singleJumpEdit = pigeonMap['singleJumpEdit'] as bool?
      ..isRoundCliping = pigeonMap['isRoundCliping'] as bool?
      ..reverseDate = pigeonMap['reverseDate'] as bool?;
  }
}

class PhotoPicker {
  /// Constructor for [PhotoPicker].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PhotoPicker({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  Future<PhotoPickerResult> pickPhoto(PhotoPickerOptions arg) async {
    final Object encoded = arg.encode();
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PhotoPicker.pickPhoto',
        const StandardMessageCodec(),
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(encoded) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return PhotoPickerResult.decode(replyMap['result']!);
    }
  }
}
